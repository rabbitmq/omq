<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>OMQ Metrics Console</title>
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
		<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		:root {
			--bg-color: #ffffff;
			--text-color: #333333;
			--card-bg: #f5f5f5;
			--border-color: #e0e0e0;
			--accent-color: #2196F3;
			--pub-color: #4CAF50;
			--cons-color: #FF9800;
			--latency-color: #9C27B0;
			--e2e-color: #F44336;
		}

		body.dark-mode {
			--bg-color: #000000;
			--text-color: #00ff00;
			--card-bg: #0a0a0a;
			--border-color: #003300;
			--accent-color: #00ff00;
			--pub-color: #00ff00;
			--cons-color: #00cc00;
			--latency-color: #00aa00;
			--e2e-color: #008800;
		}

		body {
			font-family: 'Courier New', monospace;
			background-color: var(--bg-color);
			color: var(--text-color);
			padding: 20px;
			transition: all 0.3s ease;
		}

		.header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 30px;
			padding-bottom: 20px;
			border-bottom: 2px solid var(--border-color);
		}

		h1 {
			font-size: 2em;
			color: var(--accent-color);
		}

		.theme-toggle {
			background: var(--card-bg);
			border: 2px solid var(--border-color);
			color: var(--text-color);
			padding: 10px 20px;
			cursor: pointer;
			font-family: inherit;
			font-size: 1em;
			border-radius: 5px;
			transition: all 0.3s ease;
		}

		.theme-toggle:hover {
			background: var(--accent-color);
			color: var(--bg-color);
		}

		.stats-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
			gap: 20px;
			margin-bottom: 30px;
		}

		.stat-card {
			background: var(--card-bg);
			border: 2px solid var(--border-color);
			padding: 20px;
			border-radius: 5px;
		}

		.stat-label {
			font-size: 0.9em;
			opacity: 0.8;
			margin-bottom: 5px;
		}

		.stat-value {
			font-size: 1.8em;
			font-weight: bold;
			color: var(--accent-color);
		}

		.charts-grid {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			gap: 30px;
		}


		.chart-title {
			font-size: 1.2em;
			margin-bottom: 5px;
			color: var(--accent-color);
		}

		.chart-stats {
			font-size: 0.9em;
			opacity: 0.8;
			margin-bottom: 10px;
		}

		.chart-wrapper {
			position: relative;
			height: 400px;
			overflow-x: auto;
			overflow-y: hidden;
			width: 100%;
			display: block;
		}

		.chart-wrapper canvas {
			height: 400px !important;
			display: block;
		}

		.chart-container {
			background: var(--card-bg);
			border: 2px solid var(--border-color);
			padding: 20px;
			border-radius: 5px;
			min-width: 0;
			overflow: hidden;
		}

		.error {
			background: #ff4444;
			color: white;
			padding: 15px;
			border-radius: 5px;
			margin-bottom: 20px;
			display: none;
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 1000;
			max-width: 400px;
		}

		.connection-status {
			position: fixed;
			top: 20px;
			right: 20px;
			padding: 10px 20px;
			border-radius: 5px;
			background: #ff4444;
			color: white;
			display: none;
			z-index: 999;
		}

		.connection-status.connected {
			background: #4CAF50;
		}

		@media (max-width: 1200px) {
			.charts-grid {
				grid-template-columns: 1fr;
			}
		}
		</style>
	</head>
	<body>
		<div class="connection-status" id="connection-status">Disconnected</div>

		<div class="header">
			<h1>OMQ Metrics Console</h1>
			<button class="theme-toggle" onclick="toggleTheme()">Toggle Dark Mode</button>
		</div>

		<div class="stats-grid">
			<div class="stat-card">
				<div class="stat-label">Current Time</div>
				<div class="stat-value" id="current-time">--</div>
			</div>
			<div class="stat-card">
				<div class="stat-label">Uptime</div>
				<div class="stat-value" id="uptime">--</div>
			</div>
			<div class="stat-card">
				<div class="stat-label">Total Published</div>
				<div class="stat-value" id="total-published">0</div>
			</div>
			<div class="stat-card">
				<div class="stat-label">Total Consumed</div>
				<div class="stat-value" id="total-consumed">0</div>
			</div>
		</div>

		<div class="charts-grid">
			<div class="chart-container">
				<div class="chart-title">Publishing Rate (msg/s)</div>
				<div class="chart-stats" id="pub-rate-stats">min: 0, max: 0</div>
				<div class="chart-wrapper">
					<canvas id="pub-rate-chart"></canvas>
				</div>
			</div>
			<div class="chart-container">
				<div class="chart-title">Consumption Rate (msg/s)</div>
				<div class="chart-stats" id="cons-rate-stats">min: 0, max: 0</div>
				<div class="chart-wrapper">
					<canvas id="cons-rate-chart"></canvas>
				</div>
			</div>
			<div class="chart-container">
				<div class="chart-title">Publishing Latency (ms) - p99</div>
				<div class="chart-stats" id="pub-latency-stats">min: 0, max: 0</div>
				<div class="chart-wrapper">
					<canvas id="pub-latency-chart"></canvas>
				</div>
			</div>
			<div class="chart-container">
				<div class="chart-title">End-to-End Latency (ms) - p99</div>
				<div class="chart-stats" id="e2e-latency-stats">min: 0, max: 0</div>
				<div class="chart-wrapper">
					<canvas id="e2e-latency-chart"></canvas>
				</div>
			</div>
		</div>

		<script>
		const MAX_DATA_POINTS = 3600; // Store up to 1 hour of data
		const PIXELS_PER_POINT = 10; // Width in pixels for each data point
		let startTime = null;
		let previousPublished = null;
		let previousConsumed = null;
		let isConnected = true;
		let connectionStatusElement = null;
		let dataPointCount = 0;

		// Initialize theme
		const savedTheme = localStorage.getItem('theme');
		if (savedTheme === 'dark') {
			document.body.classList.add('dark-mode');
		}

		function toggleTheme() {
			document.body.classList.toggle('dark-mode');
			const isDark = document.body.classList.contains('dark-mode');
			localStorage.setItem('theme', isDark ? 'dark' : 'light');

			// Update chart colors
			updateChartColors();
		}

		function getChartColors() {
			const isDark = document.body.classList.contains('dark-mode');
			return {
				pub: isDark ? '#00ff00' : '#4CAF50',
				cons: isDark ? '#00cc00' : '#FF9800',
				latency: isDark ? '#00aa00' : '#9C27B0',
				e2e: isDark ? '#008800' : '#F44336',
				grid: isDark ? '#003300' : '#e0e0e0',
				text: isDark ? '#00ff00' : '#333333'
			};
		}

		function createChart(canvasId, label, color) {
			const colors = getChartColors();
			const canvas = document.getElementById(canvasId);
			const wrapper = canvas.parentElement;
			const ctx = canvas.getContext('2d');

			// Set initial canvas size - start with wrapper width
			const initialWidth = wrapper.clientWidth;
			canvas.width = initialWidth;
			canvas.height = 400;
			canvas.style.width = initialWidth + 'px';
			canvas.style.height = '400px';

			return new Chart(ctx, {
				type: 'line',
				data: {
					labels: [],
					datasets: [{
						label: label,
						data: [],
						borderColor: color,
						backgroundColor: color + '33',
						borderWidth: 2,
						tension: 0.1,
						fill: true,
						pointRadius: 0,
						spanGaps: false  // Don't connect lines across null values
					}]
				},
				options: {
					responsive: false,
					maintainAspectRatio: false,
					animation: false,
					scales: {
						x: {
							display: true,
							position: 'bottom',
							grid: {
								color: colors.grid
							},
							ticks: {
								color: colors.text,
								maxRotation: 0,
								autoSkip: true,
								maxTicksLimit: 8
							}
						},
						y: {
							beginAtZero: true,
							position: 'right',
							grid: {
								color: colors.grid
							},
							ticks: {
								color: colors.text,
								precision: 0
							}
						}
					},
					plugins: {
						legend: {
							display: false
						}
					}
				}
			});
		}

		const colors = getChartColors();
		const pubRateChart = createChart('pub-rate-chart', 'Rate', colors.pub);
		const consRateChart = createChart('cons-rate-chart', 'Rate', colors.cons);
		const pubLatencyChart = createChart('pub-latency-chart', 'p99', colors.latency);
		const e2eLatencyChart = createChart('e2e-latency-chart', 'p99', colors.e2e);

		// Track min/max for each chart
		const chartStats = {
			'pub-rate-chart': { min: Infinity, max: -Infinity, statsId: 'pub-rate-stats', decimals: 0 },
			'cons-rate-chart': { min: Infinity, max: -Infinity, statsId: 'cons-rate-stats', decimals: 0 },
			'pub-latency-chart': { min: Infinity, max: -Infinity, statsId: 'pub-latency-stats', decimals: 2 },
			'e2e-latency-chart': { min: Infinity, max: -Infinity, statsId: 'e2e-latency-stats', decimals: 2 }
		};

		function updateChartColors() {
			const colors = getChartColors();
			const charts = [
				{ chart: pubRateChart, color: colors.pub },
				{ chart: consRateChart, color: colors.cons },
				{ chart: pubLatencyChart, color: colors.latency },
				{ chart: e2eLatencyChart, color: colors.e2e }
			];

			charts.forEach(({ chart, color }) => {
				chart.data.datasets[0].borderColor = color;
				chart.data.datasets[0].backgroundColor = color + '33';
				chart.options.scales.x.grid.color = colors.grid;
				chart.options.scales.y.grid.color = colors.grid;
				chart.options.scales.x.ticks.color = colors.text;
				chart.options.scales.y.ticks.color = colors.text;
				chart.update();
			});
		}

		function addDataPoint(chart, label, value, currentDataPointCount) {
			chart.data.labels.push(label);
			chart.data.datasets[0].data.push(value);

			// Keep only MAX_DATA_POINTS
			if (chart.data.labels.length > MAX_DATA_POINTS) {
				chart.data.labels.shift();
				chart.data.datasets[0].data.shift();
			}

			// Update min/max stats only after we have at least 3 data points and value is not null
			const canvasId = chart.canvas.id;
			if (chartStats[canvasId] && currentDataPointCount >= 3 && value !== null) {
				const stats = chartStats[canvasId];
				if (value < stats.min) stats.min = value;
				if (value > stats.max) stats.max = value;

				// Update the stats display
				const statsElement = document.getElementById(stats.statsId);
				if (statsElement) {
					const minVal = stats.min === Infinity ? 0 : stats.min.toFixed(stats.decimals);
					const maxVal = stats.max === -Infinity ? 0 : stats.max.toFixed(stats.decimals);
					statsElement.textContent = `min: ${minVal}, max: ${maxVal}`;
				}
			}

			// Calculate required width based on number of data points
			const wrapper = chart.canvas.parentElement;
			const totalPoints = chart.data.labels.length;
			const minWidth = wrapper.clientWidth;
			const requiredWidth = totalPoints * PIXELS_PER_POINT;
			const newWidth = Math.max(minWidth, requiredWidth);

			// Only resize if width needs to change
			if (chart.canvas.width !== newWidth) {
				chart.canvas.width = newWidth;
				chart.canvas.height = 400;
				chart.canvas.style.width = newWidth + 'px';
				chart.canvas.style.height = '400px';
				chart.resize(newWidth, 400);
			}

			chart.update('none'); // Update without animation

			// Auto-scroll to show latest data
			wrapper.scrollLeft = wrapper.scrollWidth;
		}

		function formatNumber(num) {
			if (num >= 1000000) {
				return (num / 1000000).toFixed(2) + 'M';
			} else if (num >= 1000) {
				return (num / 1000).toFixed(2) + 'K';
			}
			return num.toString();
		}

		function formatDuration(seconds) {
			const hours = Math.floor(seconds / 3600);
			const minutes = Math.floor((seconds % 3600) / 60);
			const secs = Math.floor(seconds % 60);

			if (hours > 0) {
				return `${hours}h ${minutes}m ${secs}s`;
			} else if (minutes > 0) {
				return `${minutes}m ${secs}s`;
			}
			return `${secs}s`;
		}

		function updateConnectionStatus(connected) {
			if (isConnected === connected) return;

			isConnected = connected;
			if (!connectionStatusElement) {
				connectionStatusElement = document.getElementById('connection-status');
			}

			if (connected) {
				connectionStatusElement.textContent = 'Connected';
				connectionStatusElement.classList.add('connected');
				connectionStatusElement.style.display = 'block';
				setTimeout(() => {
					connectionStatusElement.style.display = 'none';
				}, 2000);
			} else {
				connectionStatusElement.textContent = 'Disconnected - Retrying...';
				connectionStatusElement.classList.remove('connected');
				connectionStatusElement.style.display = 'block';
			}
		}

		function parsePrometheusMetrics(text) {
			const metrics = {};
			const lines = text.split('\n');

			for (const line of lines) {
				if (line.startsWith('#') || line.trim() === '') continue;

				const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\{[^}]*\})?) (.+)$/);
				if (match) {
					const [, name, value] = match;
					metrics[name] = parseFloat(value);
				}
			}
			return metrics;
		}

		async function fetchMetrics() {
			try {
				const response = await fetch('/metrics');
				if (!response.ok) {
					throw new Error(`HTTP error! status: ${response.status}`);
				}
				const text = await response.text();
				const metrics = parsePrometheusMetrics(text);

				updateConnectionStatus(true);

				// Update current time
				const now = new Date();
				document.getElementById('current-time').textContent = 
					now.toLocaleTimeString();

				// Update uptime
				if (!startTime) {
					startTime = now;
				}
				const uptime = (now - startTime) / 1000;
				document.getElementById('uptime').textContent = formatDuration(uptime);

				// Get published and consumed totals
				const published = metrics['omq_messages_published_total'] || 0;

				// Sum up consumed messages from both priorities
				let consumed = 0;
				for (const [key, value] of Object.entries(metrics)) {
					if (key.startsWith('omq_messages_consumed_total')) {
						consumed += value;
					}
				}

				// Update totals
				document.getElementById('total-published').textContent = 
					formatNumber(published);
				document.getElementById('total-consumed').textContent = 
					formatNumber(consumed);

				// Detect if metrics have reset (omq was restarted)
				if (previousPublished !== null && previousConsumed !== null) {
					if (published < previousPublished || consumed < previousConsumed) {
						console.log('Metrics reset detected - omq was restarted', {
							published, previousPublished, consumed, previousConsumed
						});

						// Add null data points to create a gap in the charts
						const timeLabel = now.toLocaleTimeString();
						addDataPoint(pubRateChart, timeLabel, null, dataPointCount);
						addDataPoint(consRateChart, timeLabel, null, dataPointCount);
						addDataPoint(pubLatencyChart, timeLabel, null, dataPointCount);
						addDataPoint(e2eLatencyChart, timeLabel, null, dataPointCount);

						// Reset tracking for new session
						previousPublished = null;
						previousConsumed = null;
						startTime = now;  // Reset uptime
						console.log('Reset complete, waiting for 2 new values...');
					}
				}

				// Calculate rates only if we have previous values
				if (previousPublished !== null && previousConsumed !== null) {
					const pubRate = published - previousPublished;
					const consRate = consumed - previousConsumed;

					console.log('Adding data points:', { pubRate, consRate, dataPointCount });

					// Increment data point counter
					dataPointCount++;

					// Only add data points after we have the second fetch (first rate calculation)
					const timeLabel = now.toLocaleTimeString();
					addDataPoint(pubRateChart, timeLabel, pubRate, dataPointCount);
					addDataPoint(consRateChart, timeLabel, consRate, dataPointCount);

					// Latency metrics (convert seconds to milliseconds)
					// Get p99 quantile
					const pubLatencyP99 = (metrics['omq_publishing_latency_seconds{quantile="0.99"}'] || 0) * 1000;
					const e2eLatencyP99 = (metrics['omq_end_to_end_latency_seconds{quantile="0.99"}'] || 0) * 1000;
					addDataPoint(pubLatencyChart, timeLabel, pubLatencyP99, dataPointCount);
					addDataPoint(e2eLatencyChart, timeLabel, e2eLatencyP99, dataPointCount);
				} else {
					console.log('Skipping data points - waiting for previous values', {
						previousPublished, previousConsumed, published, consumed
					});
				}

				// Store current values for next iteration
				previousPublished = published;
				previousConsumed = consumed;

			} catch (error) {
				console.error('Error fetching metrics:', error);
				updateConnectionStatus(false);
			}
		}

		// Fetch metrics every second
		fetchMetrics();
		setInterval(fetchMetrics, 1000);
		</script>
	</body>
</html>
